<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>安全な動画再生プレーヤー</title>
<style>
body {
  display:flex;
  flex-direction:column;
  align-items:center;
  margin-top:50px;
}
#thumbnail {
  max-width:90vw;
  height:auto;
  cursor:pointer;
  border:1px solid black;
}
#overlay {
  display:none;
  position:fixed;
  top:0; left:0;
  width:100vw; height:100vh;
  background:rgba(0,0,0,0.8);
  justify-content:center;
  align-items:center;
  z-index:9999;
}
#overlayCanvas {
  border:1px solid #fff;
  display:block;
}
</style>
</head>
<body>

<img id="thumbnail" src="" alt="thumbnail" />
<div id="overlay">
  <canvas id="overlayCanvas"></canvas>
</div>

<script type="module">
const FPS = 30;
const TOTAL_FRAMES = 1957;
let keyHex = null;
const THUMBNAIL_FILE = 'public/thumbnail.jpg.img';
const AUDIO_FILE = 'public/encrypted_audio.img';
const FRAME_PATH = 'public/encrypted_frames/';

const resKey = await fetch('key.txt');
keyHex = (await resKey.text()).trim();

const frameFiles = Array.from({ length: TOTAL_FRAMES }, (_, i) => {
  const num = String(i + 1).padStart(3, '0');
  return `${FRAME_PATH}frame${num}.jpg.img`;
});

async function decrypt(buffer) {
  const bytes = new Uint8Array(buffer);
  const iv = bytes.slice(0, 16);
  const data = bytes.slice(16);
  const keyBytes = new Uint8Array(keyHex.match(/.{2}/g).map(h => parseInt(h,16)));
  const cryptoKey = await crypto.subtle.importKey('raw', keyBytes, 'AES-CBC', false, ['decrypt']);
  return crypto.subtle.decrypt({ name:'AES-CBC', iv }, cryptoKey, data);
}

// サムネイル表示
const thumbImg = document.getElementById('thumbnail');
async function showThumbnail() {
  const res = await fetch(THUMBNAIL_FILE);
  const decrypted = await decrypt(await res.arrayBuffer());
  const blob = new Blob([decrypted], { type: 'image/jpeg' });
  thumbImg.src = URL.createObjectURL(blob);
}
await showThumbnail();

// オーバーレイ & Canvas
const overlay = document.getElementById('overlay');
const canvas = document.getElementById('overlayCanvas');
const ctx = canvas.getContext('2d');

let audioCtx = null;
let startTime = 0;
let currentFrame = -1;
let isPlaying = false;
let frameBuffer = [];

function resizeCanvas() {
  const vw = window.innerWidth * 0.9;
  const vh = window.innerHeight * 0.9;
  const aspect = 16/9;
  let width = vw;
  let height = vw / aspect;
  if(height > vh){
    height = vh;
    width = vh * aspect;
  }
  const dpr = window.devicePixelRatio || 1;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
  ctx.setTransform(1,0,0,1,0,0);
}
window.addEventListener('resize', resizeCanvas);

// 音声再生
async function playAudio() {
  if (isPlaying) return;
  isPlaying = true;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  await audioCtx.resume();
  const res = await fetch(AUDIO_FILE);
  const decrypted = await decrypt(await res.arrayBuffer());
  const buffer = await audioCtx.decodeAudioData(decrypted);
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(audioCtx.destination);
  source.start();
  startTime = audioCtx.currentTime;
}

// フレーム描画
async function drawLoop() {
  if(!audioCtx) return;
  const elapsed = audioCtx.currentTime - startTime;
  const targetFrame = Math.floor(elapsed*FPS);
  if(targetFrame>=0 && targetFrame<frameFiles.length && targetFrame!==currentFrame){
    currentFrame = targetFrame;
    if(frameBuffer.length>0){
      const bitmap = await createImageBitmap(new Blob([frameBuffer.shift()], {type:'image/jpeg'}));
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(bitmap,0,0,canvas.width,canvas.height);
      bitmap.close();
    }
    if(targetFrame+1<frameFiles.length){
      const res = await fetch(frameFiles[targetFrame+1]);
      frameBuffer.push(await decrypt(await res.arrayBuffer()));
    }
  }
  requestAnimationFrame(drawLoop);
}

// サムネクリックでオーバーレイ表示・再生開始
thumbImg.addEventListener('click', async () => {
  overlay.style.display = 'flex';
  resizeCanvas();
  if(!isPlaying){ await playAudio(); drawLoop(); }
});

// オーバーレイクリックで閉じる
overlay.addEventListener('click', () => {
  overlay.style.display = 'none';
  if(audioCtx){ 
    audioCtx.close(); 
    audioCtx = null; 
    isPlaying = false; 
    currentFrame = -1; 
    frameBuffer = [];
  }
});
</script>

</body>
</html>